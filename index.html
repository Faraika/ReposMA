<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width", initial-scale="1.0">
        <meta http-equiv="X-UA-Compatible" content="ie=edge">
        <title>Тестовая страница</title>
        <link rel="stylesheet" href="style.css">
    </head>
    <body>
        <h1>S.O.L.I.D</h1>
        <hr>
        <p>
            S.O.L.I.D - это мнемонический акроним, введённый Майклом Фэзерсом (Michael Feathers)
            для первых пяти принципов, названных Робертом Мартином в начале 2000-х, которые означали
            5 основных принципов объектно-ориентированного программирования и проектирования.
        </p>
        <p>
            <ul>
                <li>
                    S - 1 класс, функция = задача в системе.
                    Не должно быть такого, что в классе находится 300 функций, выполняющих кучу действий.
                    Необходимо выносить методы, функции из одного класса в несколько.
                    
                    Пример: у класса 4 метода > мы выносим методы в отдельные классы.
                    
                    Удобно читать код;
                    Удобно изменять код;
                    Отсутсвует GOD_Object.
                </li>
                <br>
                <li>
                    O - понятно
                    Стараться добавлять функционал не посредством изменения уже существующих сущностей,
                    а последствием добавления новой сущности и реализации изменений в ней.

                    Пример: ???

                    Не нужно проверять код на ошибки (регрессия)
                    Меньше вероятность создать ошибку
                </li>
                <br>
                <li>
                    L - понятно
                    Функции, сущности использующие родительский тип, должны так же работать с дочерними классами,
                    при этом логика работы программы не должна ломаться.

                    Пример: Есть класс пользователь, он может просматривать посты и комментировать.
                    Есть класс редактор, который наследует возможности класса пользователь, но также умеет редактировать.
                    Есть класс админ, который наследует возможности класса редактор, но также умеет выдавать роль.
                    Как итог при добавлении новой роли, нужно исключать возможность того, что к примеру Объект А,
                    будет иметь в себе возможность к примеру редактировать комментарии,
                    но не будет это делать, т.к. это не его обязанность, а обязанность редактора.
                </li>
                <br>
                <li>
                    I - понятно

                    Похож на 1 и 3.
                    Необходимо разбивать толстые интерфейсы на узкоспециализированные интерфейсы с 1 задачей, дабы пользователю было проще понимать, "Что, где, куда?"
                    
                    Пример: Есть класс "Оружие", у него есть метод attack. Появляется класс "Пистолет", но у него должен быть ещё и метод "Reload", следовательно
                    нужно добавить в класс "Оружие" ещё и метод "Reload". Добавляется класс "Нож", но нож НЕ МОЖЕТ ПЕРЕЗАРЯЖАТЬСЯ, следовательно метод "Reload"
                    не подходит для класса "Нож". Решение? Разбить класс "Оружие" - на 2 класса (Attack и Reload) и в последствии обращаться в классах
                    (Пистолет, нож и т.д.) уже к соответсвующим классам.
                    
                    Избавление сущностей от методов, которые они не используют;
                    Более предсказуемая работа программы;
                    Код становится менее связанным. 
                </li>
                <br>
                <li>
                    D - понятно
                    Модули высокого уровня не должны зависить от модулей ниже по уровню, а должны зависить от абстракций, а абстракции не должны зависить от деталей, но
                    детали должны зависить от абстраций.
                    Суть в добавлении посредников между модулями.

                    Пример: Есть "Завод", на нём есть "Работники", "Станки", "Электричество". В случае если в станке что то сломается, это можно заменить на другое, НО
                    в таком случае "Работники" уже не смогут работать со станками, т.к. не новое оборудование, а "Электричества" будет не хватать на станки, т.к. новые
                    детали требуют больше энергии. Решение? Добавление посредников (абстракции). Между "Работниками" и "Станками" - абстрация "Пульт управления".
                    Работники умеет работать с "Пультом", в свою очередь он, при подключении к нему станка, будет работать также, хоть "Станки" и поменялись.
                    А между "Электричеством" и "Станками" - абстрация "Трансформатор", который при замене деталей в "Станке" сможет сам подобрать нужное напряжение и т.д.
                </li>
            </ul>
            <br>
        </p>
        <p>
            Выше была изложена краткая информация о S.O.L.I.D
        </p>
        <hr>
        <p>
            Тут были внесены изменения 28.03.2022 в 23:15 
        </p>
    </body>
</html>